import{r as L,j as i,e as Y,c as z}from"./immer-RQ96mRkP.js";import{i as X,A as H}from"./App-qRoeme1d.js";import{V as G}from"./array-XOECqIDr.js";import{C as g}from"./colors-Ph18itwr.js";import{V}from"./ndarray-4_8-Rzfn.js";const I=(s,e)=>s>>e&1,F=(s,e)=>{for(let l=0;l<s.length;l++)s[l]^=e[l]},q=async s=>{let e=0;for(let c=0;c<s.length;c++){if(await w("msf_check_cell",{row:c,col:e,value:s[c][e],phase:"beginning"}),s[c][e]===0){for(let n=c+1;n<s.length;n++)if(s[n][e]===1){await w("msf_swap",{row1:c,row2:n,col:e,phase:"beginning"}),[s[n],s[c]]=[s[c],s[n]],await w("msf_after_swap",{matrix:s.map(r=>[...r]),phase:"beginning"});break}}if(s[c][e]===0){await w("msf_skip_column",{col:e,phase:"beginning"}),c--,e++;continue}const d=[];for(let n=c+1;n<s.length;n++)s[n][e]===1&&d.push(n);if(d.length>0){await w("msf_before_xor",{sourceRow:c,targetRows:d,col:e,phase:"beginning"});for(const n of d)F(s[n],s[c]);await w("msf_after_xor",{matrix:s.map(n=>[...n]),phase:"beginning"})}e++}e=s[0].length-1;const l=new Array(s.length).fill(!1);for(let c=s.length-1;c>=0;c--){let d=!1;for(let n=s.length-1;n>=0;n--)if(s[n][e]===1&&!l[n]){await w("msf_check_cell",{row:n,col:e,value:1,phase:"ending"});const r=[];for(let t=n-1;t>=0;t--)s[t][e]===1&&r.push(t);if(r.length>0){await w("msf_before_xor",{sourceRow:n,targetRows:r,col:e,phase:"ending"});for(const t of r)F(s[t],s[n]);await w("msf_after_xor",{matrix:s.map(t=>[...t]),phase:"ending"})}l[n]=!0,d=!0,e--;break}d||(await w("msf_skip_column",{col:e,phase:"ending"}),e--,c++)}},K=async s=>{const e=new Array(s.length).fill(-1),l=new Array(s.length).fill(-1);await w("find_active_find_starts",{starts:[...e]});for(let d=0;d<s[0].length;d++)for(let n=0;n<s.length;n++)s[n][d]===1&&e[n]===-1&&(e[n]=d,await w("find_active_start_found",{row:n,column:d,starts:[...e]}));await w("find_active_find_ends",{ends:[...l]});for(let d=s[0].length-1;d>=0;d--)for(let n=0;n<s.length;n++)s[n][d]===1&&l[n]===-1&&(l[n]=d,await w("find_active_end_found",{row:n,column:d,ends:[...l]}));await w("find_active_starts_ends",{starts:[...e],ends:[...l]});const c=[];for(let d=0;d<s[0].length;d++){c.push([]);for(let n=0;n<s.length;n++)e[n]<=d&&d<l[n]&&c[d].push(n);await w("find_active_column",{column:d,activeRows:[...c[d]],starts:e,ends:l})}return c},Z=(s,e)=>{let l=0;for(let c=0;c<s.length;c++)l^=s[c]&e[c];return l},J=async(s,e)=>{const l=[];l.push({activeRows:[],nodes:[{first:-1,second:-1}]}),await w("make_grid_init",{layer:l[0]}),e([...l]);const c=await K(s);for(let d=0;d<s[0].length;d++){const n=1<<c[d].length;l.push({activeRows:c[d],nodes:new Array(n).fill(null).map(()=>({first:-1,second:-1}))}),e([...l]),await w("make_grid_add_layer",{column:d,layer:{activeRows:[...c[d]],numNodes:n},grid:[...l]})}for(let d=0;d<s[0].length;d++){const n=l[d],r=l[d+1];await w("make_grid_process_column",{column:d,nowActiveRows:[...n.activeRows],nextActiveRows:[...r.activeRows]});const t=n.activeRows.filter(p=>r.activeRows.includes(p)),o=[...new Set([...n.activeRows,...r.activeRows])].sort((p,j)=>p-j),y=o.map(p=>s[p][d]);await w("make_grid_analyze_edges",{column:d,bothActive:t,anyActive:o,anyActiveMatrixCol:y});for(let p=0;p<n.nodes.length;p++)for(let j=0;j<r.nodes.length;j++){let $=!0;for(const R of t){const u=n.activeRows.indexOf(R),M=r.activeRows.indexOf(R);if(I(p,u)!==I(j,M)){$=!1;break}}if($){const R=[];for(const M of o){const b=n.activeRows.indexOf(M);if(b!==-1)R.push(I(p,b));else{const k=r.activeRows.indexOf(M);k!==-1&&R.push(I(j,k))}}Z(y,R)===0?(l[d].nodes[p].first=j,e([...l]),await w("make_grid_add_edge",{column:d,fromNode:p,toNode:j,edgeValue:0,grid:[...l]})):(l[d].nodes[p].second=j,e([...l]),await w("make_grid_add_edge",{column:d,fromNode:p,toNode:j,edgeValue:1,grid:[...l]}))}}}return e([...l]),await w("make_grid_complete",{grid:l}),l},Q=async(s,e)=>{const l=[];l[0]=[[0,-1,-1]],await w("decode_init",{distance:l[0][0]});for(let r=0;r<e.length;r++){const t=s[r],o=s[r+1];l[r+1]=new Array(o.nodes.length).fill(null).map(()=>[1/0,-1,-1]),await w("decode_start_column",{column:r,receivedValue:e[r],numNodes:t.nodes.length});for(let p=0;p<t.nodes.length;p++){const j=l[r][p][0];if(j===1/0)continue;const $=t.nodes[p].first;if($!==-1){const u=j+e[r]*-1;u<l[r+1][$][0]?(l[r+1][$]=[u,p,0],await w("decode_update_distance",{column:r,fromNode:p,toNode:$,edgeValue:0,oldDist:l[r+1][$][0]===1/0?"∞":l[r+1][$][0],newDist:u,isBetter:!0})):await w("decode_update_distance",{column:r,fromNode:p,toNode:$,edgeValue:0,oldDist:l[r+1][$][0],newDist:u,isBetter:!1})}const R=t.nodes[p].second;if(R!==-1){const u=j+e[r]*1;u<l[r+1][R][0]?(l[r+1][R]=[u,p,1],await w("decode_update_distance",{column:r,fromNode:p,toNode:R,edgeValue:1,oldDist:l[r+1][R][0]===1/0?"∞":l[r+1][R][0],newDist:u,isBetter:!0})):await w("decode_update_distance",{column:r,fromNode:p,toNode:R,edgeValue:1,oldDist:l[r+1][R][0],newDist:u,isBetter:!1})}}const y=l[r+1].map((p,j)=>({node:j,dist:p[0]===1/0?"∞":p[0],prev:p[1],bit:p[2]}));await w("decode_end_column",{column:r,distances:y})}await w("decode_start_backtrack",{});const c=[],d=[];let n=0;for(let r=e.length;r>0;r--){const t=l[r][n][2];c.push(t),d.push({column:r,node:n,bit:t}),await w("decode_backtrack_step",{column:r,node:n,bit:t,prevNode:l[r][n][1],path:[...d]}),n=l[r][n][1]}return await w("decode_backtrack_complete",{decoded:[...c].reverse()}),c.reverse()},E=(s,e)=>{const l=new Array(e[0].length).fill(0);for(let c=0;c<e[0].length;c++)for(let d=0;d<e.length;d++)l[c]^=s[d]&e[d][c];return l},ee=async(s,e,l=0)=>{O("generatorMatrix",s),O("originalMessage",e);const c=s.map(y=>[...y]);await w("make_msf",c),await q(c),W("msf",c),await w("msf_ready",c);const d=await J(c,y=>{W("codeGrid",y)});W("codeGrid",d),await w("grid_ready",d);const n=E(e,s);W("encoded",n),await w("encoded",n);let r=n.map(y=>1-2*y);if(l>0){const y=r.map(()=>{const p=Math.sqrt(.5*Math.pow(10,-l/10)*(s[0].length/s.length));return(Math.random()-.5)*2*p});r=r.map((p,j)=>p+y[j])}W("received",r),await w("received",r);const t=await Q(d,r);W("decoded",t),await w("decoded",t);const o=t.every((y,p)=>y===n[p]);W("isCorrect",o),await w("done",o)},oe=(s,e)=>{if(!e)return{};const l={},c={},d={};if(s.name==="msf_check_cell"){const n=s.args[0];l[`${n.row},${n.col}`]=g.BLUE,d[n.col]=g.BLUE}else if(s.name==="msf_swap"){const n=s.args[0];c[n.row1]=g.RED,c[n.row2]=g.YELLOW,d[n.col]=g.BLUE;for(let r=0;r<e[0].length;r++)l[`${n.row1},${r}`]=g.RED,l[`${n.row2},${r}`]=g.YELLOW}else if(s.name==="msf_before_xor"||s.name==="msf_after_xor"){const n=s.args[0];"sourceRow"in n&&(c[n.sourceRow]=g.BLUE,n.targetRows.forEach(r=>{c[r]=g.YELLOW}),d[n.col]=g.BLUE,l[`${n.sourceRow},${n.col}`]=g.BLUE,n.targetRows.forEach(r=>{l[`${r},${n.col}`]=g.YELLOW}))}else if(s.name==="msf_skip_column"){const n=s.args[0];d[n.col]=g.YELLOW}else if(s.name==="find_active_start_found"){const n=s.args[0];l[`${n.row},${n.column}`]=g.GREEN,d[n.column]=g.BLUE}else if(s.name==="find_active_end_found"){const n=s.args[0];l[`${n.row},${n.column}`]=g.GREEN,d[n.column]=g.BLUE}else if(s.name==="find_active_column"){const n=s.args[0];d[n.column]=g.BLUE,n.activeRows.forEach(r=>{c[r]=g.GREEN,l[`${r},${n.column}`]=g.GREEN})}else if(s.name==="make_grid_process_column"){const n=s.args[0];d[n.column]=g.BLUE,[...new Set([...n.nowActiveRows,...n.nextActiveRows])].forEach(t=>{c[t]=g.YELLOW})}else if(s.name==="decode_start_column"||s.name==="decode_end_column"){const n=s.args[0];d[n.column]=g.GREEN}else if(s.name==="decode_update_distance"){const n=s.args[0];d[n.column]=n.isBetter?g.GREEN:g.YELLOW}else if(s.name==="decode_backtrack_step"){const n=s.args[0];d[n.column]=g.GREEN}return{highlightCells:Object.keys(l).length>0?l:void 0,highlightRows:Object.keys(c).length>0?c:void 0,highlightColumns:Object.keys(d).length>0?d:void 0}},se=({curState:s,curEvent:e})=>{const l=L.useRef(null);L.useEffect(()=>{if(!l.current)return;const t=l.current,o=t.getContext("2d");if(!o)return;o.clearRect(0,0,t.width,t.height);let y=s.codeGrid;if(!y&&e.name.startsWith("make_grid_")&&(e.name==="make_grid_add_layer"||e.name==="make_grid_add_edge")){const p=e.args[0];p.grid&&(y=p.grid)}if(y){const u=[];for(let a=0;a<y.length;a++){const f=y[a].nodes,_=[],x=f.length*40,h=(t.height-x)/2;for(let m=0;m<f.length;m++)_.push({x:50+a*150,y:h+m*40});u.push(_)}let M=y.length,b=new Set,k=-1;if(e.name==="make_grid_add_layer"){const a=e.args[0];M=a.column+2,k=a.column}else if(e.name==="make_grid_add_edge"){const a=e.args[0];b.add(`${a.column}-${a.fromNode}-${a.toNode}-${a.edgeValue}`),k=a.column}else e.name==="make_grid_process_column"&&(k=e.args[0].column);for(let a=0;a<Math.min(y.length-1,M-1);a++){const f=y[a],_=u[a],x=u[a+1];for(let h=0;h<f.nodes.length;h++){const m=_[h],A=`${a}-${h}-${f.nodes[h].first}-0`,B=`${a}-${h}-${f.nodes[h].second}-1`,C=b.has(A),N=b.has(B),P=a===k,v=k!==-1&&a>k;if(f.nodes[h].first!==-1){const T=x[f.nodes[h].first];if(o.strokeStyle="#00aaff",o.lineWidth=C?5:P?2:1,o.globalAlpha=C?1:v?.3:.6,o.beginPath(),o.moveTo(m.x,m.y),o.lineTo(T.x,T.y),o.stroke(),C){const D=(m.x+T.x)/2,S=(m.y+T.y)/2;o.fillStyle="#fff",o.strokeStyle="#00aaff",o.lineWidth=2,o.beginPath(),o.arc(D,S,7,0,2*Math.PI),o.fill(),o.stroke(),o.fillStyle="#00aaff",o.font="bold 9px Arial",o.textAlign="center",o.fillText("0",D,S+3)}o.globalAlpha=1}if(f.nodes[h].second!==-1){const T=x[f.nodes[h].second];if(o.strokeStyle="#ff6600",o.lineWidth=N?5:P?2:1,o.globalAlpha=N?1:v?.3:.6,o.beginPath(),o.moveTo(m.x,m.y),o.lineTo(T.x,T.y),o.stroke(),N){const D=(m.x+T.x)/2,S=(m.y+T.y)/2;o.fillStyle="#fff",o.strokeStyle="#ff6600",o.lineWidth=2,o.beginPath(),o.arc(D,S,7,0,2*Math.PI),o.fill(),o.stroke(),o.fillStyle="#ff6600",o.font="bold 9px Arial",o.textAlign="center",o.fillText("1",D,S+3)}o.globalAlpha=1}}}if(s.decodeDistances&&e.name==="decode_end_column"){const{column:a,distances:f}=e.args[0];if(a<u.length-1){const _=u[a+1];f.forEach(x=>{if(x.node<_.length){const h=_[x.node];o.fillStyle="#000",o.font="10px Arial",o.textAlign="left";const m=x.dist===1/0||x.dist==="∞"?"∞":x.dist.toFixed(2);o.fillText(m,h.x+12,h.y)}})}}if(e.name==="decode_update_distance"){const a=e.args[0];if(a.column<u.length-1){const f=u[a.column][a.fromNode],_=u[a.column+1][a.toNode];o.strokeStyle=a.isBetter?g.GREEN:"#aaa",o.lineWidth=a.isBetter?3:1,o.setLineDash(a.isBetter?[]:[5,5]),o.beginPath(),o.moveTo(f.x,f.y),o.lineTo(_.x,_.y),o.stroke(),o.setLineDash([])}}if(e.name==="decode_backtrack_step"){const a=e.args[0];if(a.path&&a.path.length>0){o.strokeStyle=g.GREEN,o.lineWidth=4,o.setLineDash([5,5]);const f=[...a.path].sort((_,x)=>_.column-x.column);for(let _=0;_<f.length;_++){const x=f[_];if(x.column>0&&x.column<y.length){let h=-1;if(_>0){const m=f[_-1];m.column===x.column-1&&(h=m.node)}if(h===-1){for(let m=0;m<y[x.column-1].nodes.length;m++)if(x.bit===0&&y[x.column-1].nodes[m].first===x.node){h=m;break}else if(x.bit===1&&y[x.column-1].nodes[m].second===x.node){h=m;break}}if(h!==-1&&x.column>0){const m=u[x.column-1][h],A=u[x.column][x.node];o.beginPath(),o.moveTo(m.x,m.y),o.lineTo(A.x,A.y),o.stroke();const B=(m.x+A.x)/2,C=(m.y+A.y)/2;o.fillStyle="#fff",o.strokeStyle=g.GREEN,o.lineWidth=2,o.beginPath(),o.arc(B,C,8,0,2*Math.PI),o.fill(),o.stroke(),o.fillStyle="#000",o.font="bold 9px Arial",o.textAlign="center",o.fillText(x.bit.toString(),B,C+3)}}}o.setLineDash([])}if(a.prevNode!==-1&&a.column>0&&a.column<u.length){const f=u[a.column-1][a.prevNode],_=u[a.column][a.node];o.strokeStyle=g.GREEN,o.lineWidth=5,o.beginPath(),o.moveTo(f.x,f.y),o.lineTo(_.x,_.y),o.stroke()}if(a.column<u.length&&a.column>=0){const f=u[a.column][a.node];o.fillStyle=g.YELLOW,o.strokeStyle=g.GREEN,o.lineWidth=4,o.beginPath(),o.arc(f.x,f.y,12,0,2*Math.PI),o.fill(),o.stroke(),o.fillStyle="#000",o.font="bold 11px Arial",o.textAlign="center",o.fillText(`bit:${a.bit}`,f.x,f.y+20)}}if(s.decoded&&s.decoded.length>0&&(e.name==="decoded"||e.name==="done")){o.strokeStyle=g.GREEN,o.lineWidth=4;let a=0;for(let f=0;f<s.decoded.length;f++){const _=s.decoded[f],x=u[f][a];let h=-1;if(_===0&&y[f].nodes[a].first!==-1?h=y[f].nodes[a].first:_===1&&y[f].nodes[a].second!==-1&&(h=y[f].nodes[a].second),h!==-1){const m=u[f+1][h];o.beginPath(),o.moveTo(x.x,x.y),o.lineTo(m.x,m.y),o.stroke(),o.fillStyle=g.GREEN,o.strokeStyle=g.GREEN,o.lineWidth=3,o.beginPath(),o.arc(m.x,m.y,10,0,2*Math.PI),o.fill(),o.stroke(),a=h}}}for(let a=0;a<Math.min(u.length,M);a++){const f=u[a];for(let _=0;_<f.length;_++){const x=f[_];let h=!1,m="#fff",A="#000",B=2,C=8;if(e.name==="make_grid_add_layer"){const N=e.args[0];a===N.column+1&&(h=!0,m=g.YELLOW,A=g.BLUE,B=3,C=10)}if(e.name==="decode_update_distance"){const N=e.args[0];a===N.column&&N.fromNode===_?(h=!0,m=g.BLUE,A=g.BLUE,B=3,C=10):a===N.column+1&&N.toNode===_&&(h=!0,m=N.isBetter?g.GREEN:g.YELLOW,A=N.isBetter?g.GREEN:g.RED,B=3,C=10)}else if(e.name==="decode_backtrack_step"){const N=e.args[0];a===N.column&&N.node===_&&(h=!0,m=g.YELLOW,A=g.GREEN,B=4,C=12)}o.fillStyle=h?m:"#fff",o.strokeStyle=h?A:"#000",o.lineWidth=h?B:2,o.beginPath(),o.arc(x.x,x.y,C,0,2*Math.PI),o.fill(),o.stroke(),o.fillStyle="#000",o.font="10px Arial",o.textAlign="center",o.fillText(_.toString(),x.x,x.y-C-4)}}o.fillStyle="#000",o.font="12px Arial",o.textAlign="center";for(let a=0;a<Math.min(y.length,M);a++){const f=50+a*150;let _="#000",x="normal";if(e.name==="make_grid_add_layer"){const h=e.args[0];a===h.column+1&&(_=g.BLUE,x="bold")}else if(e.name==="make_grid_process_column"){const h=e.args[0];(a===h.column||a===h.column+1)&&(_=g.BLUE,x="bold")}else if(e.name.startsWith("decode_")){const h=e.args[0];h.column!==void 0&&(a===h.column||a===h.column+1)&&(_=g.GREEN,x="bold")}o.fillStyle=_,o.font=`${x} 12px Arial`,o.fillText(`L${a}`,f,30)}}},[s,e]);const d=(()=>{if(e.name==="msf_after_swap"||e.name==="msf_after_xor"){const t=e.args[0];if(t.matrix)return t.matrix}return s.msf?s.msf:s.generatorMatrix})(),n=oe(e,s.msf||s.generatorMatrix),r=()=>{if(e.name.startsWith("msf_")){if(e.name==="msf_check_cell"){const t=e.args[0];return`Checking cell [${t.row}, ${t.col}] (${t.phase} phase)`}else if(e.name==="msf_swap"){const t=e.args[0];return`Swapping rows ${t.row1} and ${t.row2} at column ${t.col} (${t.phase} phase)`}else if(e.name==="msf_before_xor"){const t=e.args[0];return`XORing row ${t.sourceRow} into rows [${t.targetRows.join(", ")}] at column ${t.col} (${t.phase} phase)`}else if(e.name==="msf_skip_column"){const t=e.args[0];return`Skipping column ${t.col} (${t.phase} phase)`}return"Processing Minimal Span Form"}else if(e.name.startsWith("find_active_")){if(e.name==="find_active_start_found"){const t=e.args[0];return`Found start for row ${t.row} at column ${t.column}`}else if(e.name==="find_active_end_found"){const t=e.args[0];return`Found end for row ${t.row} at column ${t.column}`}else if(e.name==="find_active_column"){const t=e.args[0];return`Column ${t.column}: Active rows [${t.activeRows.join(", ")}]`}return"Finding Active Spans"}else if(e.name.startsWith("make_grid_")){if(e.name==="make_grid_add_layer"){const t=e.args[0];return`Adding layer ${t.column} with ${t.layer.numNodes} nodes (active rows: [${t.layer.activeRows.join(", ")}])`}else if(e.name==="make_grid_add_edge"){const t=e.args[0];return`Adding edge: Node ${t.fromNode} → Node ${t.toNode} (value: ${t.edgeValue})`}return"Building Trellis Grid"}else if(e.name.startsWith("decode_")){if(e.name==="decode_start_column"){const t=e.args[0];return`Processing column ${t.column}, received value: ${t.receivedValue.toFixed(3)}`}else if(e.name==="decode_update_distance"){const t=e.args[0];return`${t.isBetter?"✓":"✗"} Node ${t.fromNode} → Node ${t.toNode}, distance: ${t.newDist.toFixed(3)}`}else if(e.name==="decode_backtrack_step"){const t=e.args[0];return`Backtrack: Column ${t.column}, Node ${t.node}, Bit: ${t.bit}`}return"Viterbi Decoding"}return e.name};return i.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:"20px",padding:"20px"},children:[i.jsxs("div",{style:{padding:"10px",backgroundColor:"#f0f0f0",borderRadius:"5px",border:"2px solid #ccc"},children:[i.jsx("strong",{children:"Current Step:"})," ",r()]}),s.generatorMatrix&&i.jsxs("div",{children:[i.jsx("h3",{children:"Generator Matrix"}),i.jsx(V,{array:s.generatorMatrix,label:"Generator Matrix",...s.msf?{}:n})]}),s.msf&&i.jsxs("div",{children:[i.jsx("h3",{children:e.name.startsWith("msf_")&&typeof e.args[0]=="object"&&e.args[0]!==null&&"phase"in e.args[0]&&e.args[0].phase==="beginning"?"Minimal Span Form (Making Beginnings Unique)":e.name.startsWith("msf_")&&typeof e.args[0]=="object"&&e.args[0]!==null&&"phase"in e.args[0]&&e.args[0].phase==="ending"?"Minimal Span Form (Making Endings Unique)":"Minimal Span Form"}),d&&i.jsxs("div",{children:[i.jsx(V,{array:d,label:"MSF Matrix",highlightCells:n.highlightCells,highlightRows:n.highlightRows,highlightColumns:n.highlightColumns}),e.name==="msf_swap"&&i.jsxs("div",{style:{marginTop:"10px",padding:"5px",backgroundColor:"#ffe8e8",borderRadius:"3px"},children:[i.jsx("strong",{children:"Action:"})," Swapping rows ",e.args[0].row1," and ",e.args[0].row2," at column ",e.args[0].col]}),e.name==="msf_before_xor"&&"sourceRow"in e.args[0]&&i.jsxs("div",{style:{marginTop:"10px",padding:"5px",backgroundColor:"#e8f4f8",borderRadius:"3px"},children:[i.jsx("strong",{children:"Action:"})," XORing row ",e.args[0].sourceRow," into rows [",e.args[0].targetRows.join(", "),"] at column ",e.args[0].col]})]})]}),s.activeSpans&&i.jsxs("div",{children:[i.jsx("h3",{children:"Active Spans"}),i.jsxs("div",{style:{display:"flex",gap:"20px"},children:[i.jsxs("div",{children:[i.jsx("strong",{children:"Row Starts:"}),i.jsx("div",{style:{fontFamily:"monospace",fontSize:"14px",marginTop:"5px"},children:s.activeSpans.starts.map((t,o)=>i.jsxs("div",{children:["Row ",o,": Column ",t===-1?"N/A":t]},o))})]}),i.jsxs("div",{children:[i.jsx("strong",{children:"Row Ends:"}),i.jsx("div",{style:{fontFamily:"monospace",fontSize:"14px",marginTop:"5px"},children:s.activeSpans.ends.map((t,o)=>i.jsxs("div",{children:["Row ",o,": Column ",t===-1?"N/A":t]},o))})]})]}),s.activeSpans.columnActiveRows&&i.jsxs("div",{style:{marginTop:"10px"},children:[i.jsx("strong",{children:"Active Rows by Column:"}),i.jsx("div",{style:{fontFamily:"monospace",fontSize:"12px",marginTop:"5px"},children:s.activeSpans.columnActiveRows.map((t,o)=>i.jsxs("div",{children:["Column ",o,": [",t.join(", "),"]"]},o))})]}),e.name==="find_active_column"&&i.jsxs("div",{style:{marginTop:"10px",padding:"5px",backgroundColor:"#e8f4f8",borderRadius:"3px"},children:[i.jsx("strong",{children:"Current:"})," Column ",e.args[0].column,", Active rows: [",e.args[0].activeRows.join(", "),"]"]})]}),s.codeGrid&&i.jsxs("div",{children:[i.jsx("h3",{children:"Trellis Diagram"}),e.name.startsWith("make_grid_")&&i.jsxs("div",{style:{marginBottom:"10px",padding:"5px",backgroundColor:"#e8f4f8",borderRadius:"3px"},children:[e.name==="make_grid_add_layer"&&i.jsxs("div",{children:[i.jsx("strong",{children:"Action:"})," Adding layer ",e.args[0].column," with ",e.args[0].layer.numNodes," nodes (active rows: [",e.args[0].layer.activeRows.join(", "),"])"]}),e.name==="make_grid_add_edge"&&i.jsxs("div",{children:[i.jsx("strong",{children:"Action:"})," Adding edge: Node ",e.args[0].fromNode," → Node ",e.args[0].toNode," (value: ",e.args[0].edgeValue,")"]})]}),i.jsx("canvas",{ref:l,width:800,height:400,style:{border:"1px solid #ccc",backgroundColor:"#f9f9f9"}}),i.jsxs("div",{style:{marginTop:"10px",fontSize:"12px"},children:[i.jsx("span",{style:{color:"#00aaff"},children:"Blue edges: 0"})," |",i.jsx("span",{style:{color:"#ff6600"},children:" Orange edges: 1"}),s.decoded&&i.jsxs("span",{children:[" | ",i.jsx("span",{style:{color:g.GREEN},children:"Green: Decoded path"})]})]})]}),(e.name.startsWith("decode_")||s.decoded)&&i.jsxs("div",{children:[i.jsx("h3",{children:"Viterbi Decoding"}),e.name==="decode_start_column"&&i.jsxs("div",{style:{padding:"5px",backgroundColor:"#e8f4f8",borderRadius:"3px"},children:[i.jsxs("strong",{children:["Processing column ",e.args[0].column]}),", received value: ",e.args[0].receivedValue.toFixed(3)]}),e.name==="decode_update_distance"&&i.jsxs("div",{style:{padding:"5px",backgroundColor:e.args[0].isBetter?"#e8f8e8":"#f8e8e8",borderRadius:"3px"},children:[e.args[0].isBetter?"✓":"✗"," Node ",e.args[0].fromNode," → Node ",e.args[0].toNode,"(edge: ",e.args[0].edgeValue,"): Old dist: ",e.args[0].oldDist,", New dist: ",e.args[0].newDist.toFixed(3)]}),e.name==="decode_end_column"&&i.jsxs("div",{children:[i.jsx("div",{style:{marginBottom:"5px"},children:i.jsxs("strong",{children:["Column ",e.args[0].column," distances:"]})}),i.jsx("div",{style:{fontSize:"12px",fontFamily:"monospace",padding:"5px",backgroundColor:"#f9f9f9",borderRadius:"3px"},children:e.args[0].distances.map(t=>`Node ${t.node}: dist=${t.dist===1/0||t.dist==="∞"?"∞":t.dist.toFixed(2)}, prev=${t.prev}, bit=${t.bit}`).join(`
`)})]}),e.name==="decode_backtrack_step"&&i.jsxs("div",{style:{padding:"5px",backgroundColor:"#fff8e8",borderRadius:"3px"},children:[i.jsxs("div",{children:[i.jsx("strong",{children:"Backtrack:"})," Column ",e.args[0].column,", Node ",e.args[0].node,", Bit: ",e.args[0].bit,", Prev: ",e.args[0].prevNode]}),"path"in e.args[0]&&e.args[0].path&&i.jsxs("div",{style:{fontSize:"12px",marginTop:"5px"},children:["Path so far: ",e.args[0].path.map(t=>`C${t.column}:N${t.node}:${t.bit}`).join(" → ")]})]})]}),i.jsxs("div",{children:[i.jsx("h3",{children:"Messages"}),i.jsxs("div",{style:{display:"flex",flexDirection:"row",gap:"20px",flexWrap:"wrap"},children:[s.originalMessage&&i.jsxs("div",{children:[i.jsx("h4",{children:"Original Message"}),i.jsx(G,{array:s.originalMessage,label:"Message"})]}),s.encoded&&i.jsxs("div",{children:[i.jsx("h4",{children:"Encoded"}),i.jsx(G,{array:s.encoded,label:"Encoded"})]}),s.received&&i.jsxs("div",{children:[i.jsx("h4",{children:"Received (with noise)"}),i.jsx(G,{array:s.received.map(t=>t.toFixed(2)),label:"Received"})]}),s.decoded&&i.jsxs("div",{children:[i.jsx("h4",{children:"Decoded"}),i.jsx(G,{array:s.decoded,label:"Decoded",color:s.isCorrect?g.GREEN:g.RED})]})]})]}),s.isCorrect!==void 0&&i.jsxs("div",{style:{padding:"10px",backgroundColor:s.isCorrect?"#e8f8e8":"#f8e8e8",borderRadius:"5px",border:`2px solid ${s.isCorrect?g.GREEN:g.RED}`},children:[i.jsx("h3",{style:{color:s.isCorrect?g.GREEN:g.RED,margin:0},children:s.isCorrect?"✓ Decoding Correct":"✗ Decoding Error"}),s.encoded&&s.decoded&&i.jsxs("div",{style:{marginTop:"10px",fontSize:"14px"},children:["Encoded: [",s.encoded.join(", "),"]",i.jsx("br",{}),"Decoded: [",s.decoded.join(", "),"]"]})]})]})},ne=({doStart:s})=>{const[e,l]=L.useState(6),[c,d]=L.useState(3),[n,r]=L.useState(0),[t,o]=L.useState(`1 0 1 1 0 0
0 1 0 1 1 0
0 0 1 0 1 1`),[y,p]=L.useState("1 0 1"),j=(b,k,a)=>{const f=b.trim().split(`
`);if(f.length!==k)return null;const _=[];for(const x of f){const h=x.trim().split(/\s+/).map(m=>parseInt(m));if(h.length!==a||h.some(m=>isNaN(m)||m!==0&&m!==1))return null;_.push(h)}return _},$=(b,k)=>{const a=b.trim().split(/\s+/).map(f=>parseInt(f));return a.length!==k||a.some(f=>isNaN(f)||f!==0&&f!==1)?null:a},R=L.useCallback(b=>{const k=j(t,c,e),a=$(y,c);if(!k){alert("Invalid generator matrix. Please enter k×n binary matrix (0s and 1s)");return}if(!a){alert("Invalid message. Please enter k binary values (0s and 1s)");return}s([k,a,n],b)},[e,c,n,t,y,s]),u=L.useCallback(()=>{const b=[];for(let k=0;k<c;k++){const a=[];for(let f=0;f<e;f++)a.push(Math.random()<.5?0:1);b.push(a)}o(b.map(k=>k.join(" ")).join(`
`))},[c,e]),M=L.useCallback(()=>{const b=Array.from({length:c},()=>Math.random()<.5?0:1);p(b.join(" "))},[c]);return i.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:"10px",padding:"10px"},children:[i.jsx("div",{children:i.jsxs("label",{children:["Codeword length (n):",i.jsx("input",{type:"number",value:e,onChange:b=>l(parseInt(b.target.value)||6),min:2,max:20})]})}),i.jsx("div",{children:i.jsxs("label",{children:["Message length (k):",i.jsx("input",{type:"number",value:c,onChange:b=>d(parseInt(b.target.value)||3),min:1,max:e})]})}),i.jsxs("div",{children:[i.jsxs("label",{children:["Generator Matrix (k×n, one row per line, space-separated):",i.jsx("button",{onClick:u,style:{marginLeft:"10px"},children:"Generate Random"})]}),i.jsx("textarea",{value:t,onChange:b=>o(b.target.value),rows:c,cols:e*2+5,style:{fontFamily:"monospace",width:"100%"}})]}),i.jsxs("div",{children:[i.jsxs("label",{children:["Message (k bits, space-separated):",i.jsx("button",{onClick:M,style:{marginLeft:"10px"},children:"Generate Random"})]}),i.jsx("input",{type:"text",value:y,onChange:b=>p(b.target.value),style:{fontFamily:"monospace",width:"100%"}})]}),i.jsx("div",{children:i.jsxs("label",{children:["Noise Level (SNR in dB, 0 = no noise):",i.jsx("input",{type:"number",value:n,onChange:b=>r(parseFloat(b.target.value)||0),min:0,max:20,step:.5})]})}),i.jsxs("div",{style:{display:"flex",gap:"10px"},children:[i.jsx("button",{onClick:()=>R(!1),children:"Start"}),i.jsx("button",{onClick:()=>R(!0),children:"Run Full"})]})]})},U={algo:ee,startComponent:ne,renderComponent:se,nameEn:"Viterbi Algorithm",descriptionEn:"Viterbi decoding algorithm for linear block codes",authorEn:"Alzhanov Maksim",nameRu:"Алгоритм Витерби",descriptionRu:"Алгоритм декодирования Витерби для линейных блоковых кодов",authorRu:"Альжанов Максим"},{bind:O,here:w,update:W,store:te}=X(U);Y();document.getElementById("root");z.createRoot(document.getElementById("root")).render(i.jsx(L.StrictMode,{children:i.jsx(H,{manifest:U,store:te})}));
