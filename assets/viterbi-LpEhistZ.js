import{r as T,j as i,e as Z,c as J}from"./immer-RQ96mRkP.js";import{i as Q,A as E}from"./App-qRoeme1d.js";import{V as O}from"./array-XOECqIDr.js";import{C as g}from"./colors-Ph18itwr.js";import{V as z}from"./ndarray-4_8-Rzfn.js";const U=(s,e)=>s>>e&1,q=(s,e)=>{for(let l=0;l<s.length;l++)s[l]^=e[l]},ee=async s=>{let e=0;for(let c=0;c<s.length;c++){if(await _("msf_check_cell",{row:c,col:e,value:s[c][e],phase:"beginning"}),s[c][e]===0){for(let n=c+1;n<s.length;n++)if(s[n][e]===1){await _("msf_swap",{row1:c,row2:n,col:e,phase:"beginning"}),[s[n],s[c]]=[s[c],s[n]],await _("msf_after_swap",{matrix:s.map(r=>[...r]),phase:"beginning"});break}}if(s[c][e]===0){await _("msf_skip_column",{col:e,phase:"beginning"}),c--,e++;continue}const d=[];for(let n=c+1;n<s.length;n++)s[n][e]===1&&d.push(n);if(d.length>0){await _("msf_before_xor",{sourceRow:c,targetRows:d,col:e,phase:"beginning"});for(const n of d)q(s[n],s[c]);await _("msf_after_xor",{matrix:s.map(n=>[...n]),phase:"beginning"})}e++}e=s[0].length-1;const l=new Array(s.length).fill(!1);for(let c=s.length-1;c>=0;c--){let d=!1;for(let n=s.length-1;n>=0;n--)if(s[n][e]===1&&!l[n]){await _("msf_check_cell",{row:n,col:e,value:1,phase:"ending"});const r=[];for(let t=n-1;t>=0;t--)s[t][e]===1&&r.push(t);if(r.length>0){await _("msf_before_xor",{sourceRow:n,targetRows:r,col:e,phase:"ending"});for(const t of r)q(s[t],s[n]);await _("msf_after_xor",{matrix:s.map(t=>[...t]),phase:"ending"})}l[n]=!0,d=!0,e--;break}d||(await _("msf_skip_column",{col:e,phase:"ending"}),e--,c++)}},oe=async s=>{const e=new Array(s.length).fill(-1),l=new Array(s.length).fill(-1);await _("find_active_find_starts",{starts:[...e]});for(let d=0;d<s[0].length;d++)for(let n=0;n<s.length;n++)s[n][d]===1&&e[n]===-1&&(e[n]=d,await _("find_active_start_found",{row:n,column:d,starts:[...e]}));await _("find_active_find_ends",{ends:[...l]});for(let d=s[0].length-1;d>=0;d--)for(let n=0;n<s.length;n++)s[n][d]===1&&l[n]===-1&&(l[n]=d,await _("find_active_end_found",{row:n,column:d,ends:[...l]}));await _("find_active_starts_ends",{starts:[...e],ends:[...l]});const c=[];for(let d=0;d<s[0].length;d++){c.push([]);for(let n=0;n<s.length;n++)e[n]<=d&&d<l[n]&&c[d].push(n);await _("find_active_column",{column:d,activeRows:[...c[d]],starts:e,ends:l})}return c},se=(s,e)=>{let l=0;for(let c=0;c<s.length;c++)l^=s[c]&e[c];return l},ne=async(s,e)=>{const l=[];l.push({activeRows:[],nodes:[{first:-1,second:-1}]}),await _("make_grid_init",{layer:l[0]}),e([...l]);const c=await oe(s);for(let d=0;d<s[0].length;d++){const n=1<<c[d].length;l.push({activeRows:c[d],nodes:new Array(n).fill(null).map(()=>({first:-1,second:-1}))}),e([...l]),await _("make_grid_add_layer",{column:d,layer:{activeRows:[...c[d]],numNodes:n},grid:[...l]})}for(let d=0;d<s[0].length;d++){const n=l[d],r=l[d+1];await _("make_grid_process_column",{column:d,nowActiveRows:[...n.activeRows],nextActiveRows:[...r.activeRows]});const t=n.activeRows.filter(h=>r.activeRows.includes(h)),o=[...new Set([...n.activeRows,...r.activeRows])].sort((h,k)=>h-k),w=o.map(h=>s[h][d]);await _("make_grid_analyze_edges",{column:d,bothActive:t,anyActive:o,anyActiveMatrixCol:w});for(let h=0;h<n.nodes.length;h++)for(let k=0;k<r.nodes.length;k++){let C=!0;for(const j of t){const R=n.activeRows.indexOf(j),S=r.activeRows.indexOf(j);if(U(h,R)!==U(k,S)){C=!1;break}}if(C){const j=[];for(const S of o){const u=n.activeRows.indexOf(S);if(u!==-1)j.push(U(h,u));else{const N=r.activeRows.indexOf(S);N!==-1&&j.push(U(k,N))}}se(w,j)===0?(l[d].nodes[h].first=k,e([...l]),await _("make_grid_add_edge",{column:d,fromNode:h,toNode:k,edgeValue:0,grid:[...l]})):(l[d].nodes[h].second=k,e([...l]),await _("make_grid_add_edge",{column:d,fromNode:h,toNode:k,edgeValue:1,grid:[...l]}))}}}return e([...l]),await _("make_grid_complete",{grid:l}),l},te=async(s,e)=>{const l=[];l[0]=[[0,-1,-1]],await _("decode_init",{distance:l[0][0]});for(let r=0;r<e.length;r++){const t=s[r],o=s[r+1];l[r+1]=new Array(o.nodes.length).fill(null).map(()=>[1/0,-1,-1]),await _("decode_start_column",{column:r,receivedValue:e[r],numNodes:t.nodes.length});for(let h=0;h<t.nodes.length;h++){const k=l[r][h][0];if(k===1/0)continue;const C=t.nodes[h].first;if(C!==-1){const R=k+e[r]*-1;R<l[r+1][C][0]?(l[r+1][C]=[R,h,0],await _("decode_update_distance",{column:r,fromNode:h,toNode:C,edgeValue:0,oldDist:l[r+1][C][0]===1/0?"∞":l[r+1][C][0],newDist:R,isBetter:!0})):await _("decode_update_distance",{column:r,fromNode:h,toNode:C,edgeValue:0,oldDist:l[r+1][C][0],newDist:R,isBetter:!1})}const j=t.nodes[h].second;if(j!==-1){const R=k+e[r]*1;R<l[r+1][j][0]?(l[r+1][j]=[R,h,1],await _("decode_update_distance",{column:r,fromNode:h,toNode:j,edgeValue:1,oldDist:l[r+1][j][0]===1/0?"∞":l[r+1][j][0],newDist:R,isBetter:!0})):await _("decode_update_distance",{column:r,fromNode:h,toNode:j,edgeValue:1,oldDist:l[r+1][j][0],newDist:R,isBetter:!1})}}const w=l[r+1].map((h,k)=>({node:k,dist:h[0]===1/0?"∞":h[0],prev:h[1],bit:h[2]}));await _("decode_end_column",{column:r,distances:w})}await _("decode_start_backtrack",{});const c=[],d=[];let n=0;for(let r=e.length;r>0;r--){const t=l[r][n][2];c.push(t),d.push({column:r,node:n,bit:t}),await _("decode_backtrack_step",{column:r,node:n,bit:t,prevNode:l[r][n][1],path:[...d]}),n=l[r][n][1]}return await _("decode_backtrack_complete",{decoded:[...c].reverse()}),c.reverse()},ie=(s,e)=>{const l=new Array(e[0].length).fill(0);for(let c=0;c<e[0].length;c++)for(let d=0;d<e.length;d++)l[c]^=s[d]&e[d][c];return l},ae=async(s,e,l=0)=>{X("generatorMatrix",s),X("originalMessage",e);const c=s.map(w=>[...w]);await _("make_msf",c),await ee(c),v("msf",c),await _("msf_ready",c);const d=await ne(c,w=>{v("codeGrid",w)});v("codeGrid",d),await _("grid_ready",d);const n=ie(e,s);v("encoded",n),await _("encoded",n);let r=n.map(w=>1-2*w);if(l>0){const w=r.map(()=>{const h=Math.sqrt(.5*Math.pow(10,-l/10)*(s[0].length/s.length));return(Math.random()-.5)*2*h});r=r.map((h,k)=>h+w[k])}v("received",r),await _("received",r);const t=await te(d,r);v("decoded",t),await _("decoded",t);const o=t.every((w,h)=>w===n[h]);v("isCorrect",o),await _("done",o)},le=(s,e)=>{if(!e)return{};const l={},c={},d={};if(s.name==="msf_check_cell"){const n=s.args[0];l[`${n.row},${n.col}`]=g.BLUE,d[n.col]=g.BLUE}else if(s.name==="msf_swap"){const n=s.args[0];c[n.row1]=g.RED,c[n.row2]=g.YELLOW,d[n.col]=g.BLUE;for(let r=0;r<e[0].length;r++)l[`${n.row1},${r}`]=g.RED,l[`${n.row2},${r}`]=g.YELLOW}else if(s.name==="msf_before_xor"||s.name==="msf_after_xor"){const n=s.args[0];"sourceRow"in n&&(c[n.sourceRow]=g.BLUE,n.targetRows.forEach(r=>{c[r]=g.YELLOW}),d[n.col]=g.BLUE,l[`${n.sourceRow},${n.col}`]=g.BLUE,n.targetRows.forEach(r=>{l[`${r},${n.col}`]=g.YELLOW}))}else if(s.name==="msf_skip_column"){const n=s.args[0];d[n.col]=g.YELLOW}else if(s.name==="find_active_start_found"){const n=s.args[0];l[`${n.row},${n.column}`]=g.GREEN,d[n.column]=g.BLUE}else if(s.name==="find_active_end_found"){const n=s.args[0];l[`${n.row},${n.column}`]=g.GREEN,d[n.column]=g.BLUE}else if(s.name==="find_active_column"){const n=s.args[0];d[n.column]=g.BLUE,n.activeRows.forEach(r=>{c[r]=g.GREEN,l[`${r},${n.column}`]=g.GREEN})}else if(s.name==="make_grid_process_column"){const n=s.args[0];d[n.column]=g.BLUE,[...new Set([...n.nowActiveRows,...n.nextActiveRows])].forEach(t=>{c[t]=g.YELLOW})}else if(s.name==="decode_start_column"||s.name==="decode_end_column"){const n=s.args[0];d[n.column]=g.GREEN}else if(s.name==="decode_update_distance"){const n=s.args[0];d[n.column]=n.isBetter?g.GREEN:g.YELLOW}else if(s.name==="decode_backtrack_step"){const n=s.args[0];d[n.column]=g.GREEN}return{highlightCells:Object.keys(l).length>0?l:void 0,highlightRows:Object.keys(c).length>0?c:void 0,highlightColumns:Object.keys(d).length>0?d:void 0}},de=({curState:s,curEvent:e})=>{const l=T.useRef(null);T.useEffect(()=>{if(!l.current)return;const t=l.current,o=t.getContext("2d");if(!o)return;let w=s.codeGrid;if(!w&&e.name.startsWith("make_grid_")&&(e.name==="make_grid_add_layer"||e.name==="make_grid_add_edge")){const h=e.args[0];h.grid&&(w=h.grid)}if(w&&w.length>0){const R=w.length,S=Math.max(...w.map(a=>a.nodes.length),1),u=R*150+50*2,N=S*40+50*2+30;t.width=Math.max(800,u),t.height=Math.max(400,N),o.clearRect(0,0,t.width,t.height);const A=50,M=80,b=[];for(let a=0;a<w.length;a++){const m=w[a].nodes,y=[],p=m.length*40,f=M+(S*40-p)/2;for(let x=0;x<m.length;x++)y.push({x:A+a*150,y:f+x*40});b.push(y)}let P=w.length,I=new Set,W=-1;if(e.name==="make_grid_add_layer"){const a=e.args[0];P=a.column+2,W=a.column}else if(e.name==="make_grid_add_edge"){const a=e.args[0];I.add(`${a.column}-${a.fromNode}-${a.toNode}-${a.edgeValue}`),W=a.column}else e.name==="make_grid_process_column"&&(W=e.args[0].column);for(let a=0;a<Math.min(w.length-1,P-1);a++){const m=w[a],y=b[a],p=b[a+1];for(let f=0;f<m.nodes.length;f++){const x=y[f],B=`${a}-${f}-${m.nodes[f].first}-0`,D=`${a}-${f}-${m.nodes[f].second}-1`,L=I.has(B),$=I.has(D),Y=a===W,H=W!==-1&&a>W;if(m.nodes[f].first!==-1){const G=p[m.nodes[f].first];if(o.strokeStyle="#00aaff",o.lineWidth=L?5:Y?2:1,o.globalAlpha=L?1:H?.3:.6,o.beginPath(),o.moveTo(x.x,x.y),o.lineTo(G.x,G.y),o.stroke(),L){const V=(x.x+G.x)/2,F=(x.y+G.y)/2;o.fillStyle="#fff",o.strokeStyle="#00aaff",o.lineWidth=2,o.beginPath(),o.arc(V,F,7,0,2*Math.PI),o.fill(),o.stroke(),o.fillStyle="#00aaff",o.font="bold 9px Arial",o.textAlign="center",o.fillText("0",V,F+3)}o.globalAlpha=1}if(m.nodes[f].second!==-1){const G=p[m.nodes[f].second];if(o.strokeStyle="#ff6600",o.lineWidth=$?5:Y?2:1,o.globalAlpha=$?1:H?.3:.6,o.beginPath(),o.moveTo(x.x,x.y),o.lineTo(G.x,G.y),o.stroke(),$){const V=(x.x+G.x)/2,F=(x.y+G.y)/2;o.fillStyle="#fff",o.strokeStyle="#ff6600",o.lineWidth=2,o.beginPath(),o.arc(V,F,7,0,2*Math.PI),o.fill(),o.stroke(),o.fillStyle="#ff6600",o.font="bold 9px Arial",o.textAlign="center",o.fillText("1",V,F+3)}o.globalAlpha=1}}}if(s.decodeDistances&&e.name==="decode_end_column"){const{column:a,distances:m}=e.args[0];if(a<b.length-1){const y=b[a+1];m.forEach(p=>{if(p.node<y.length){const f=y[p.node];o.fillStyle="#000",o.font="10px Arial",o.textAlign="left";const x=p.dist===1/0||p.dist==="∞"?"∞":p.dist.toFixed(2);o.fillText(x,f.x+12,f.y)}})}}if(e.name==="decode_update_distance"){const a=e.args[0];if(a.column<b.length-1){const m=b[a.column][a.fromNode],y=b[a.column+1][a.toNode];o.strokeStyle=a.isBetter?g.GREEN:"#aaa",o.lineWidth=a.isBetter?3:1,o.setLineDash(a.isBetter?[]:[5,5]),o.beginPath(),o.moveTo(m.x,m.y),o.lineTo(y.x,y.y),o.stroke(),o.setLineDash([])}}if(e.name==="decode_backtrack_step"){const a=e.args[0];if(a.path&&a.path.length>0){o.strokeStyle=g.GREEN,o.lineWidth=4,o.setLineDash([5,5]);const m=[...a.path].sort((y,p)=>y.column-p.column);for(let y=0;y<m.length;y++){const p=m[y];if(p.column>0&&p.column<w.length){let f=-1;if(y>0){const x=m[y-1];x.column===p.column-1&&(f=x.node)}if(f===-1){for(let x=0;x<w[p.column-1].nodes.length;x++)if(p.bit===0&&w[p.column-1].nodes[x].first===p.node){f=x;break}else if(p.bit===1&&w[p.column-1].nodes[x].second===p.node){f=x;break}}if(f!==-1&&p.column>0){const x=b[p.column-1][f],B=b[p.column][p.node];o.beginPath(),o.moveTo(x.x,x.y),o.lineTo(B.x,B.y),o.stroke();const D=(x.x+B.x)/2,L=(x.y+B.y)/2;o.fillStyle="#fff",o.strokeStyle=g.GREEN,o.lineWidth=2,o.beginPath(),o.arc(D,L,8,0,2*Math.PI),o.fill(),o.stroke(),o.fillStyle="#000",o.font="bold 9px Arial",o.textAlign="center",o.fillText(p.bit.toString(),D,L+3)}}}o.setLineDash([])}if(a.prevNode!==-1&&a.column>0&&a.column<b.length){const m=b[a.column-1][a.prevNode],y=b[a.column][a.node];o.strokeStyle=g.GREEN,o.lineWidth=5,o.beginPath(),o.moveTo(m.x,m.y),o.lineTo(y.x,y.y),o.stroke()}if(a.column<b.length&&a.column>=0){const m=b[a.column][a.node];o.fillStyle=g.YELLOW,o.strokeStyle=g.GREEN,o.lineWidth=4,o.beginPath(),o.arc(m.x,m.y,12,0,2*Math.PI),o.fill(),o.stroke(),o.fillStyle="#000",o.font="bold 11px Arial",o.textAlign="center",o.fillText(`bit:${a.bit}`,m.x,m.y+20)}}if(s.decoded&&s.decoded.length>0&&(e.name==="decoded"||e.name==="done")){o.strokeStyle=g.GREEN,o.lineWidth=4;let a=0;for(let m=0;m<s.decoded.length;m++){const y=s.decoded[m],p=b[m][a];let f=-1;if(y===0&&w[m].nodes[a].first!==-1?f=w[m].nodes[a].first:y===1&&w[m].nodes[a].second!==-1&&(f=w[m].nodes[a].second),f!==-1){const x=b[m+1][f];o.beginPath(),o.moveTo(p.x,p.y),o.lineTo(x.x,x.y),o.stroke(),o.fillStyle=g.GREEN,o.strokeStyle=g.GREEN,o.lineWidth=3,o.beginPath(),o.arc(x.x,x.y,10,0,2*Math.PI),o.fill(),o.stroke(),a=f}}}for(let a=0;a<Math.min(b.length,P);a++){const m=b[a];for(let y=0;y<m.length;y++){const p=m[y];let f=!1,x="#fff",B="#000",D=2,L=8;if(e.name==="make_grid_add_layer"){const $=e.args[0];a===$.column+1&&(f=!0,x=g.YELLOW,B=g.BLUE,D=3,L=10)}if(e.name==="decode_update_distance"){const $=e.args[0];a===$.column&&$.fromNode===y?(f=!0,x=g.BLUE,B=g.BLUE,D=3,L=10):a===$.column+1&&$.toNode===y&&(f=!0,x=$.isBetter?g.GREEN:g.YELLOW,B=$.isBetter?g.GREEN:g.RED,D=3,L=10)}else if(e.name==="decode_backtrack_step"){const $=e.args[0];a===$.column&&$.node===y&&(f=!0,x=g.YELLOW,B=g.GREEN,D=4,L=12)}o.fillStyle=f?x:"#fff",o.strokeStyle=f?B:"#000",o.lineWidth=f?D:2,o.beginPath(),o.arc(p.x,p.y,L,0,2*Math.PI),o.fill(),o.stroke(),o.fillStyle="#000",o.font="10px Arial",o.textAlign="center",o.fillText(y.toString(),p.x,p.y-L-4)}}o.fillStyle="#000",o.font="12px Arial",o.textAlign="center";for(let a=0;a<Math.min(w.length,P);a++){const m=A+a*150;let y="#000",p="normal";if(e.name==="make_grid_add_layer"){const f=e.args[0];a===f.column+1&&(y=g.BLUE,p="bold")}else if(e.name==="make_grid_process_column"){const f=e.args[0];(a===f.column||a===f.column+1)&&(y=g.BLUE,p="bold")}else if(e.name.startsWith("decode_")){const f=e.args[0];f.column!==void 0&&(a===f.column||a===f.column+1)&&(y=g.GREEN,p="bold")}o.fillStyle=y,o.font=`${p} 12px Arial`,o.fillText(`L${a}`,m,M-10)}}else t.width=800,t.height=400,o.clearRect(0,0,t.width,t.height)},[s,e]);const d=(()=>{if(e.name==="msf_after_swap"||e.name==="msf_after_xor"){const t=e.args[0];if(t.matrix)return t.matrix}return s.msf?s.msf:s.generatorMatrix})(),n=le(e,s.msf||s.generatorMatrix),r=()=>{if(e.name.startsWith("msf_")){if(e.name==="msf_check_cell"){const t=e.args[0];return`Checking cell [${t.row}, ${t.col}] (${t.phase} phase)`}else if(e.name==="msf_swap"){const t=e.args[0];return`Swapping rows ${t.row1} and ${t.row2} at column ${t.col} (${t.phase} phase)`}else if(e.name==="msf_before_xor"){const t=e.args[0];return`XORing row ${t.sourceRow} into rows [${t.targetRows.join(", ")}] at column ${t.col} (${t.phase} phase)`}else if(e.name==="msf_skip_column"){const t=e.args[0];return`Skipping column ${t.col} (${t.phase} phase)`}return"Processing Minimal Span Form"}else if(e.name.startsWith("find_active_")){if(e.name==="find_active_start_found"){const t=e.args[0];return`Found start for row ${t.row} at column ${t.column}`}else if(e.name==="find_active_end_found"){const t=e.args[0];return`Found end for row ${t.row} at column ${t.column}`}else if(e.name==="find_active_column"){const t=e.args[0];return`Column ${t.column}: Active rows [${t.activeRows.join(", ")}]`}return"Finding Active Spans"}else if(e.name.startsWith("make_grid_")){if(e.name==="make_grid_add_layer"){const t=e.args[0];return`Adding layer ${t.column} with ${t.layer.numNodes} nodes (active rows: [${t.layer.activeRows.join(", ")}])`}else if(e.name==="make_grid_add_edge"){const t=e.args[0];return`Adding edge: Node ${t.fromNode} → Node ${t.toNode} (value: ${t.edgeValue})`}return"Building Trellis Grid"}else if(e.name.startsWith("decode_")){if(e.name==="decode_start_column"){const t=e.args[0];return`Processing column ${t.column}, received value: ${t.receivedValue.toFixed(3)}`}else if(e.name==="decode_update_distance"){const t=e.args[0];return`${t.isBetter?"✓":"✗"} Node ${t.fromNode} → Node ${t.toNode}, distance: ${t.newDist.toFixed(3)}`}else if(e.name==="decode_backtrack_step"){const t=e.args[0];return`Backtrack: Column ${t.column}, Node ${t.node}, Bit: ${t.bit}`}return"Viterbi Decoding"}return e.name};return i.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:"20px",padding:"20px"},children:[i.jsxs("div",{style:{padding:"10px",backgroundColor:"#f0f0f0",borderRadius:"5px",border:"2px solid #ccc"},children:[i.jsx("strong",{children:"Current Step:"})," ",r()]}),s.generatorMatrix&&i.jsxs("div",{children:[i.jsx("h3",{children:"Generator Matrix"}),i.jsx(z,{array:s.generatorMatrix,label:"Generator Matrix",...s.msf?{}:n})]}),s.msf&&i.jsxs("div",{children:[i.jsx("h3",{children:e.name.startsWith("msf_")&&typeof e.args[0]=="object"&&e.args[0]!==null&&"phase"in e.args[0]&&e.args[0].phase==="beginning"?"Minimal Span Form (Making Beginnings Unique)":e.name.startsWith("msf_")&&typeof e.args[0]=="object"&&e.args[0]!==null&&"phase"in e.args[0]&&e.args[0].phase==="ending"?"Minimal Span Form (Making Endings Unique)":"Minimal Span Form"}),d&&i.jsxs("div",{children:[i.jsx(z,{array:d,label:"MSF Matrix",highlightCells:n.highlightCells,highlightRows:n.highlightRows,highlightColumns:n.highlightColumns}),e.name==="msf_swap"&&i.jsxs("div",{style:{marginTop:"10px",padding:"5px",backgroundColor:"#ffe8e8",borderRadius:"3px"},children:[i.jsx("strong",{children:"Action:"})," Swapping rows ",e.args[0].row1," and ",e.args[0].row2," at column ",e.args[0].col]}),e.name==="msf_before_xor"&&"sourceRow"in e.args[0]&&i.jsxs("div",{style:{marginTop:"10px",padding:"5px",backgroundColor:"#e8f4f8",borderRadius:"3px"},children:[i.jsx("strong",{children:"Action:"})," XORing row ",e.args[0].sourceRow," into rows [",e.args[0].targetRows.join(", "),"] at column ",e.args[0].col]})]})]}),s.activeSpans&&i.jsxs("div",{children:[i.jsx("h3",{children:"Active Spans"}),i.jsxs("div",{style:{display:"flex",gap:"20px"},children:[i.jsxs("div",{children:[i.jsx("strong",{children:"Row Starts:"}),i.jsx("div",{style:{fontFamily:"monospace",fontSize:"14px",marginTop:"5px"},children:s.activeSpans.starts.map((t,o)=>i.jsxs("div",{children:["Row ",o,": Column ",t===-1?"N/A":t]},o))})]}),i.jsxs("div",{children:[i.jsx("strong",{children:"Row Ends:"}),i.jsx("div",{style:{fontFamily:"monospace",fontSize:"14px",marginTop:"5px"},children:s.activeSpans.ends.map((t,o)=>i.jsxs("div",{children:["Row ",o,": Column ",t===-1?"N/A":t]},o))})]})]}),s.activeSpans.columnActiveRows&&i.jsxs("div",{style:{marginTop:"10px"},children:[i.jsx("strong",{children:"Active Rows by Column:"}),i.jsx("div",{style:{fontFamily:"monospace",fontSize:"12px",marginTop:"5px"},children:s.activeSpans.columnActiveRows.map((t,o)=>i.jsxs("div",{children:["Column ",o,": [",t.join(", "),"]"]},o))})]}),e.name==="find_active_column"&&i.jsxs("div",{style:{marginTop:"10px",padding:"5px",backgroundColor:"#e8f4f8",borderRadius:"3px"},children:[i.jsx("strong",{children:"Current:"})," Column ",e.args[0].column,", Active rows: [",e.args[0].activeRows.join(", "),"]"]})]}),(s.codeGrid||e.name.startsWith("make_grid_"))&&i.jsxs("div",{children:[i.jsx("h3",{children:"Trellis Diagram"}),e.name.startsWith("make_grid_")&&i.jsxs("div",{style:{marginBottom:"10px",padding:"5px",backgroundColor:"#e8f4f8",borderRadius:"3px"},children:[e.name==="make_grid_add_layer"&&i.jsxs("div",{children:[i.jsx("strong",{children:"Action:"})," Adding layer ",e.args[0].column," with ",e.args[0].layer.numNodes," nodes (active rows: [",e.args[0].layer.activeRows.join(", "),"])"]}),e.name==="make_grid_add_edge"&&i.jsxs("div",{children:[i.jsx("strong",{children:"Action:"})," Adding edge: Node ",e.args[0].fromNode," → Node ",e.args[0].toNode," (value: ",e.args[0].edgeValue,")"]})]}),i.jsx("div",{style:{overflow:"auto",maxWidth:"100%"},children:i.jsx("canvas",{ref:l,style:{border:"1px solid #ccc",backgroundColor:"#f9f9f9",display:"block"}})}),i.jsxs("div",{style:{marginTop:"10px",fontSize:"12px"},children:[i.jsx("span",{style:{color:"#00aaff"},children:"Blue edges: 0"})," |",i.jsx("span",{style:{color:"#ff6600"},children:" Orange edges: 1"}),s.decoded&&i.jsxs("span",{children:[" | ",i.jsx("span",{style:{color:g.GREEN},children:"Green: Decoded path"})]})]})]}),(e.name.startsWith("decode_")||s.decoded)&&i.jsxs("div",{children:[i.jsx("h3",{children:"Viterbi Decoding"}),e.name==="decode_start_column"&&i.jsxs("div",{style:{padding:"5px",backgroundColor:"#e8f4f8",borderRadius:"3px"},children:[i.jsxs("strong",{children:["Processing column ",e.args[0].column]}),", received value: ",e.args[0].receivedValue.toFixed(3)]}),e.name==="decode_update_distance"&&i.jsxs("div",{style:{padding:"5px",backgroundColor:e.args[0].isBetter?"#e8f8e8":"#f8e8e8",borderRadius:"3px"},children:[e.args[0].isBetter?"✓":"✗"," Node ",e.args[0].fromNode," → Node ",e.args[0].toNode,"(edge: ",e.args[0].edgeValue,"): Old dist: ",e.args[0].oldDist,", New dist: ",e.args[0].newDist.toFixed(3)]}),e.name==="decode_end_column"&&i.jsxs("div",{children:[i.jsx("div",{style:{marginBottom:"5px"},children:i.jsxs("strong",{children:["Column ",e.args[0].column," distances:"]})}),i.jsx("div",{style:{fontSize:"12px",fontFamily:"monospace",padding:"5px",backgroundColor:"#f9f9f9",borderRadius:"3px"},children:e.args[0].distances.map(t=>`Node ${t.node}: dist=${t.dist===1/0||t.dist==="∞"?"∞":t.dist.toFixed(2)}, prev=${t.prev}, bit=${t.bit}`).join(`
`)})]}),e.name==="decode_backtrack_step"&&i.jsxs("div",{style:{padding:"5px",backgroundColor:"#fff8e8",borderRadius:"3px"},children:[i.jsxs("div",{children:[i.jsx("strong",{children:"Backtrack:"})," Column ",e.args[0].column,", Node ",e.args[0].node,", Bit: ",e.args[0].bit,", Prev: ",e.args[0].prevNode]}),"path"in e.args[0]&&e.args[0].path&&i.jsxs("div",{style:{fontSize:"12px",marginTop:"5px"},children:["Path so far: ",e.args[0].path.map(t=>`C${t.column}:N${t.node}:${t.bit}`).join(" → ")]})]})]}),i.jsxs("div",{children:[i.jsx("h3",{children:"Messages"}),i.jsxs("div",{style:{display:"flex",flexDirection:"row",gap:"20px",flexWrap:"wrap"},children:[s.originalMessage&&i.jsxs("div",{children:[i.jsx("h4",{children:"Original Message"}),i.jsx(O,{array:s.originalMessage,label:"Message"})]}),s.encoded&&i.jsxs("div",{children:[i.jsx("h4",{children:"Encoded"}),i.jsx(O,{array:s.encoded,label:"Encoded"})]}),s.received&&i.jsxs("div",{children:[i.jsx("h4",{children:"Received (with noise)"}),i.jsx(O,{array:s.received.map(t=>t.toFixed(2)),label:"Received"})]}),s.decoded&&i.jsxs("div",{children:[i.jsx("h4",{children:"Decoded"}),i.jsx(O,{array:s.decoded,label:"Decoded",color:s.isCorrect?g.GREEN:g.RED})]})]})]}),s.isCorrect!==void 0&&i.jsxs("div",{style:{padding:"10px",backgroundColor:s.isCorrect?"#e8f8e8":"#f8e8e8",borderRadius:"5px",border:`2px solid ${s.isCorrect?g.GREEN:g.RED}`},children:[i.jsx("h3",{style:{color:s.isCorrect?g.GREEN:g.RED,margin:0},children:s.isCorrect?"✓ Decoding Correct":"✗ Decoding Error"}),s.encoded&&s.decoded&&i.jsxs("div",{style:{marginTop:"10px",fontSize:"14px"},children:["Encoded: [",s.encoded.join(", "),"]",i.jsx("br",{}),"Decoded: [",s.decoded.join(", "),"]"]})]})]})},re=({doStart:s})=>{const[e,l]=T.useState(6),[c,d]=T.useState(3),[n,r]=T.useState(0),[t,o]=T.useState(`1 0 1 1 0 0
0 1 0 1 1 0
0 0 1 0 1 1`),[w,h]=T.useState("1 0 1"),k=(u,N,A)=>{const M=u.trim().split(`
`);if(M.length!==N)return null;const b=[];for(const P of M){const I=P.trim().split(/\s+/).map(W=>parseInt(W));if(I.length!==A||I.some(W=>isNaN(W)||W!==0&&W!==1))return null;b.push(I)}return b},C=(u,N)=>{const A=u.trim().split(/\s+/).map(M=>parseInt(M));return A.length!==N||A.some(M=>isNaN(M)||M!==0&&M!==1)?null:A},j=T.useCallback(u=>{const N=k(t,c,e),A=C(w,c);if(!N){alert("Invalid generator matrix. Please enter k×n binary matrix (0s and 1s)");return}if(!A){alert("Invalid message. Please enter k binary values (0s and 1s)");return}s([N,A,n],u)},[e,c,n,t,w,s]),R=T.useCallback(()=>{const u=[];for(let N=0;N<c;N++){const A=[];for(let M=0;M<e;M++)A.push(Math.random()<.5?0:1);u.push(A)}o(u.map(N=>N.join(" ")).join(`
`))},[c,e]),S=T.useCallback(()=>{const u=Array.from({length:c},()=>Math.random()<.5?0:1);h(u.join(" "))},[c]);return i.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:"10px",padding:"10px"},children:[i.jsx("div",{children:i.jsxs("label",{children:["Codeword length (n):",i.jsx("input",{type:"number",value:e,onChange:u=>l(parseInt(u.target.value)||6),min:2,max:20})]})}),i.jsx("div",{children:i.jsxs("label",{children:["Message length (k):",i.jsx("input",{type:"number",value:c,onChange:u=>d(parseInt(u.target.value)||3),min:1,max:e})]})}),i.jsxs("div",{children:[i.jsxs("label",{children:["Generator Matrix (k×n, one row per line, space-separated):",i.jsx("button",{onClick:R,style:{marginLeft:"10px"},children:"Generate Random"})]}),i.jsx("textarea",{value:t,onChange:u=>o(u.target.value),rows:c,cols:e*2+5,style:{fontFamily:"monospace",width:"100%"}})]}),i.jsxs("div",{children:[i.jsxs("label",{children:["Message (k bits, space-separated):",i.jsx("button",{onClick:S,style:{marginLeft:"10px"},children:"Generate Random"})]}),i.jsx("input",{type:"text",value:w,onChange:u=>h(u.target.value),style:{fontFamily:"monospace",width:"100%"}})]}),i.jsx("div",{children:i.jsxs("label",{children:["Noise Level (SNR in dB, 0 = no noise):",i.jsx("input",{type:"number",value:n,onChange:u=>r(parseFloat(u.target.value)||0),min:0,max:20,step:.5})]})}),i.jsxs("div",{style:{display:"flex",gap:"10px"},children:[i.jsx("button",{onClick:()=>j(!1),children:"Start"}),i.jsx("button",{onClick:()=>j(!0),children:"Run Full"})]})]})},K={algo:ae,startComponent:re,renderComponent:de,nameEn:"Viterbi Algorithm",descriptionEn:"Viterbi decoding algorithm for linear block codes",authorEn:"Alzhanov Maksim",nameRu:"Алгоритм Витерби",descriptionRu:"Алгоритм декодирования Витерби для линейных блоковых кодов",authorRu:"Альжанов Максим"},{bind:X,here:_,update:v,store:ce}=Q(K);Z();document.getElementById("root");J.createRoot(document.getElementById("root")).render(i.jsx(T.StrictMode,{children:i.jsx(E,{manifest:K,store:ce})}));
